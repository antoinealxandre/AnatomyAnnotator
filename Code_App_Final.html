<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="theme-color" content="#0A1A3A" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta
      name="description"
      content="Une application pour annoter des images anatomiques avec des masques et des catégories prédéfinies."
    />
    <link
      rel="apple-touch-icon"
      href="https://img.icons8.com/fluency/180/000000/heart-with-pulse.png"
    />
    <link
      rel="icon"
      href="https://img.icons8.com/fluency/48/000000/heart-with-pulse.png"
    />
    <title>Anatomy Annotator 🫀</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN"
      crossorigin="anonymous"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
      rel="stylesheet"
      integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA=="
      crossorigin="anonymous"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <link rel="manifest" href="/manifest.json" />
    <style>
      :root {
        --primary-color: #00897b;
        --secondary-color: #004d40;
        --accent-color: #e0f2f1;
        --bg-dark: #0a1a3a;
        --text-light: #b0bec5dd;
        --text-dark: #eee;
        --canvas-bg: rgba(20, 40, 55, 0.4);
        --shadow-cyan: rgba(0, 255, 255, 0.3);
        --glow-green: rgba(38, 166, 154, 0.6);
        --button-gradient: linear-gradient(145deg, #00897b, #004d40);
        --button-hover-gradient: linear-gradient(145deg, #26a69a, #00bcd4);
      }

      html,
      body {
        margin: 0;
        padding: 0;
        height: 100vh;
        font-family: "Inter", sans-serif;
        background: var(--bg-dark);
        color: var(--text-dark);
        overflow: hidden;
        position: fixed;
        width: 100%;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }

      canvas#background {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 0;
        background: radial-gradient(
          circle,
          rgba(10, 26, 58, 0.8),
          rgba(5, 15, 40, 1)
        );
      }

      body > *:not(canvas#background) {
        position: relative;
        z-index: 2;
      }

      .main-container {
        position: fixed;
        top: 10px;
        left: 0;
        right: 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        justify-content: center;
        gap: 16px;
        box-sizing: border-box;
      }

      .canvas-wrapper {
        background: var(--canvas-bg);
        backdrop-filter: blur(12px);
        border-radius: 12px;
        box-shadow: 0 8px 32px var(--shadow-cyan);
        padding: 6px;
        margin: 0;
        width: 100%;
        max-width: min(1000px, 95vw);
        position: relative;
        animation: fadeInUp 1.4s ease forwards 0.6s;
        user-select: none;
        transition: transform 0.25s ease, box-shadow 0.25s ease;
        overflow: hidden;
      }

      .canvas-wrapper::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          90deg,
          transparent,
          var(--glow-green),
          transparent
        );
        animation: glowPulse 2s ease-in-out infinite;
        z-index: 3;
      }

      .canvas-wrapper::after {
        content: "";
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          90deg,
          transparent,
          var(--glow-green),
          transparent
        );
        animation: glowPulseReverse 2s ease-in-out infinite;
        z-index: 3;
      }

      .canvas-wrapper:hover {
        transform: scale(1.02);
        box-shadow: 0 12px 40px var(--shadow-cyan);
      }

      .canvas-area {
        width: 100%;
        height: clamp(40vh, 70vh, 75vh);
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        overflow: hidden;
        border-radius: 8px;
      }

      #canvas {
        width: 100%;
        height: 100%;
        object-fit: contain;
        border-radius: 8px;
        border: 2px solid var(--primary-color);
        cursor: crosshair;
        touch-action: none;
      }

      .no-image-placeholder {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: var(--text-light);
        text-align: center;
        background: rgba(30, 50, 65, 0.4);
        border-radius: 8px;
        text-shadow: 0 0 6px rgba(0, 0, 0, 0.3);
      }

      .no-image-placeholder img {
        width: clamp(50px, 12vw, 60px);
        height: clamp(50px, 12vw, 60px);
        margin-bottom: 8px;
        transition: transform 0.3s ease;
      }

      .no-image-placeholder img:hover {
        transform: scale(1.1);
      }

      .no-image-placeholder h5 {
        font-size: clamp(15px, 3.2vw, 17px);
        font-weight: 600;
        margin-bottom: 5px;
        color: var(--accent-color);
      }

      .no-image-placeholder p {
        font-size: clamp(11px, 2.8vw, 13px);
        max-width: 90%;
        color: var(--text-light);
      }

      .category-panel {
        background: var(--canvas-bg);
        backdrop-filter: blur(12px);
        border-radius: 12px;
        box-shadow: 0 8px 32px var(--shadow-cyan);
        padding: 1rem;
        width: 100%;
        max-width: min(240px, 75vw);
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        animation: fadeInUp 1.4s ease forwards 0.8s;
        user-select: none;
        transition: transform 0.25s ease, box-shadow 0.25s ease;
        overflow: hidden;
      }

      .category-panel:hover {
        transform: scale(1.02);
        box-shadow: 0 12px 40px var(--shadow-cyan);
      }

      .category-panel button {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.35rem 0.5rem;
        border-radius: 8px;
        font-weight: 600;
        font-size: clamp(0.65rem, 1.5vw, 0.8rem);
        color: var(--accent-color);
        cursor: pointer;
        border: none;
        box-shadow: 0 0 8px var(--shadow-cyan),
          inset 0 1px 4px rgba(255, 255, 255, 0.15);
        transition: transform 0.25s ease, box-shadow 0.25s ease,
          filter 0.4s ease, background 0.2s ease;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        width: 100%;
        min-height: 28px;
      }

      #cat1 {
        background: rgb(22, 163, 74);
      }
      #cat2 {
        background: rgb(37, 99, 235);
      }
      #cat3 {
        background: rgb(217, 119, 6);
      }
      #cat4 {
        background: rgb(148, 0, 211);
      }
      #cat5 {
        background: rgb(185, 28, 28);
      }

      .category-panel button:hover:not(.disabled),
      .category-panel button:focus-visible:not(.disabled) {
        filter: brightness(1.2);
        box-shadow: 0 0 12px var(--shadow-cyan),
          inset 0 2px 8px rgba(255, 255, 255, 0.25);
        transform: scale(1.05);
      }

      .category-panel button.active {
        filter: brightness(1.3);
        box-shadow: 0 0 16px var(--shadow-cyan),
          inset 0 2px 8px rgba(255, 255, 255, 0.3);
        transform: scale(1.06);
        border: 2px solid var(--accent-color);
      }

      .category-panel button i {
        font-size: clamp(10px, 1.6vw, 12px);
        color: #ffffff;
        flex-shrink: 0;
      }

      .toolbar {
        width: 100%;
        margin-bottom: 6px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 5px;
        background: rgba(20, 40, 55, 0.4);
        backdrop-filter: blur(12px);
        padding: 4px 6px;
        border-radius: 16px;
        box-shadow: 0 4px 12px var(--shadow-cyan);
        flex-wrap: wrap;
      }

      .left-buttons,
      .right-buttons {
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
      }

      .bottom-right-toolbar {
        position: absolute;
        bottom: 20px;
        right: 20px;
        display: flex;
        gap: 5px;
        background: rgba(20, 40, 55, 0.4);
        backdrop-filter: blur(12px);
        padding: 4px 6px;
        border-radius: 16px;
        box-shadow: 0 4px 12px var(--shadow-cyan);
      }

      .toolbar button,
      .bottom-right-toolbar button {
        width: clamp(30px, 7vw, 34px);
        height: clamp(30px, 7vw, 34px);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(15px, 3.2vw, 17px);
        background: var(--button-gradient);
        color: var(--accent-color);
        border: none;
        box-shadow: 0 0 8px var(--shadow-cyan),
          inset 0 1px 4px rgba(255, 255, 255, 0.15);
        transition: transform 0.25s ease, box-shadow 0.25s ease,
          background 0.4s ease;
        cursor: pointer;
      }

      .toolbar button:hover,
      .bottom-right-toolbar button:hover {
        background: var(--button-hover-gradient);
        box-shadow: 0 0 12px var(--shadow-cyan);
        transform: scale(1.1);
      }

      .tooltip-inner {
        background: var(--canvas-bg);
        color: var(--accent-color);
        font-family: "Inter", sans-serif;
        font-size: clamp(10px, 2.5vw, 12px);
        padding: 4px 8px;
        border-radius: 4px;
        box-shadow: 0 4px 8px var(--shadow-cyan);
        backdrop-filter: blur(12px);
      }

      .progress-container {
        position: fixed;
        inset: 0;
        background: #004d40dd;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(4px);
        z-index: 99;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.4s ease;
      }

      .progress-container.active {
        opacity: 1;
        pointer-events: all;
      }

      .progress-bar {
        border: 3px solid #004d40;
        border-top: 3px solid #26a69a;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        box-shadow: 0 0 10px #26a69a;
      }

      .modal {
        z-index: 1050;
      }

      .modal-backdrop {
        z-index: 1040;
        position: fixed;
      }

      .modal-open {
        padding-right: 0 !important;
      }

      .modal-content {
        background: var(--canvas-bg);
        color: var(--accent-color);
        border-radius: 16px;
        box-shadow: 0 8px 32px var(--shadow-cyan);
        border: none;
        backdrop-filter: blur(12px);
        transition: transform 0.3s ease, opacity 0.3s ease;
        animation: modalPop 0.4s ease forwards;
      }

      .modal-content:hover {
        transform: scale(1.02);
      }

      .modal-content .btn-close {
        background: transparent;
        filter: opacity(0.5);
      }

      .modal-content .btn-primary {
        background: var(--button-gradient);
        color: var(--accent-color);
        border: none;
        border-radius: 8px;
        box-shadow: 0 0 8px var(--shadow-cyan);
        transition: transform 0.25s ease, box-shadow 0.25s ease,
          background 0.4s ease;
      }

      .modal-content .btn-primary:hover {
        background: var(--button-hover-gradient);
        transform: scale(1.05);
        box-shadow: 0 0 12px var(--shadow-cyan);
      }

      .modal-content .form-check-label {
        color: var(--accent-color);
      }

      .modal-header {
        border-bottom: none;
        padding: 1rem 1.5rem;
        background: var(--button-gradient);
        color: var(--accent-color);
        border-top-left-radius: 16px;
        border-top-right-radius: 16px;
        position: relative;
        overflow: hidden;
      }

      .modal-header::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
          circle at top,
          rgba(38, 166, 154, 0.3),
          transparent
        );
        opacity: 0.5;
      }

      .modal-footer {
        border-top: none;
        padding: 0.8rem 1.5rem;
        justify-content: space-between;
        background: linear-gradient(180deg, transparent, rgba(20, 40, 55, 0.2));
      }

      .modal-body {
        padding: 1.5rem;
        line-height: 1.6;
      }

      .modal-body strong {
        color: var(--primary-color);
        font-weight: 700;
      }

      #tutorialModal .modal-body strong {
        color: #ffffff;
      }

      .modal-body p {
        margin: 0.5rem 0;
        color: var(--text-light);
      }

      .modal-title {
        font-size: 1.3rem;
        font-weight: 700;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      }

      @keyframes glowPulse {
        0%,
        100% {
          opacity: 0.6;
          transform: translateX(-10%);
        }
        50% {
          opacity: 1;
          transform: translateX(10%);
        }
      }

      @keyframes glowPulseReverse {
        0%,
        100% {
          opacity: 0.6;
          transform: translateX(10%);
        }
        50% {
          opacity: 1;
          transform: translateX(-10%);
        }
      }

      @keyframes modalPop {
        0% {
          transform: scale(0.8);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      @media (min-width: 768px) {
        .main-container {
          flex-direction: row;
          justify-content: center;
          align-items: flex-start;
          gap: 20px;
          position: fixed;
          top: 10px;
          left: 0;
          right: 0;
        }

        .canvas-wrapper {
          max-width: min(900px, 75vw);
        }

        .canvas-area {
          height: clamp(50vh, 75vh, 80vh);
        }

        .category-panel {
          max-width: min(240px, 18vw);
          padding: 1.2rem;
          gap: 0.5rem;
        }

        .category-panel button {
          padding: 0.45rem 0.7rem;
          font-size: 0.85rem;
          min-height: 32px;
        }

        .category-panel button i {
          font-size: 0.8rem;
        }
      }

      @media (max-width: 576px) {
        .main-container {
          padding-top: 10px;
        }

        .canvas-area {
          height: clamp(30vh, 60vh, 65vh);
        }

        .toolbar {
          padding: 4px 6px;
        }

        .bottom-right-toolbar {
          padding: 4px 6px;
        }

        .category-panel {
          padding: 0.7rem;
          gap: 0.4rem;
          max-width: 100%;
        }

        .category-panel button {
          font-size: clamp(0.55rem, 1.1vw, 0.7rem);
          padding: 0.15rem 0.35rem;
          min-height: 26px;
        }

        .category-panel button i {
          font-size: clamp(9px, 1.3vw, 11px);
        }

        .category-panel button.active {
          transform: scale(1.04);
          box-shadow: 0 0 14px var(--shadow-cyan);
        }

        .modal-title {
          font-size: 1.1rem;
        }

        .modal-body {
          padding: 1rem;
        }
      }

      #tutorialModal .modal-dialog {
        position: fixed;
        bottom: 10vh;
        left: 50%;
        transform: translateX(-50%);
        margin: 0;
        max-width: 90vw;
      }
    </style>
  </head>
  <body>
    <canvas id="background"></canvas>
    <div class="progress-container" id="progressContainer">
      <div class="progress-bar"></div>
    </div>

    <div class="main-container">
      <div class="canvas-wrapper">
        <div class="toolbar" id="toolbar">
          <div class="left-buttons">
            <button
              class="btn"
              id="newImageBtn"
              data-bs-toggle="tooltip"
              data-bs-placement="top"
              title="Charger"
            >
              <i class="fas fa-download"></i>
            </button>
            <button
              class="btn"
              id="saveBtn"
              data-bs-toggle="tooltip"
              data-bs-placement="top"
              title="Enregistrer"
            >
              <i class="fas fa-save"></i>
            </button>
            <button
              class="btn"
              id="historyBtn"
              data-bs-toggle="tooltip"
              data-bs-placement="top"
              title="Historique"
            >
              <i class="fas fa-history"></i>
            </button>
            <button
              class="btn"
              id="toggleAnnotationsBtn"
              data-bs-toggle="tooltip"
              data-bs-placement="top"
              title="Afficher/Masquer"
            >
              <i class="fas fa-eye"></i>
            </button>
          </div>
          <div class="right-buttons">
            <button
              class="btn"
              id="tutorialBtn"
              data-bs-toggle="tooltip"
              data-bs-placement="top"
              title="Aide"
            >
              <i class="fas fa-question-circle"></i>
            </button>
            <button
              class="btn"
              id="backBtn"
              data-bs-toggle="tooltip"
              data-bs-placement="top"
              title="Retour"
            >
              <i class="fas fa-arrow-left"></i>
            </button>
          </div>
        </div>
        <div class="canvas-area">
          <div class="no-image-placeholder" id="noImagePlaceholder">
            <img
              src="https://img.icons8.com/?size=100&id=114618&format=png"
              alt="X-Ray Person Icon"
            />
            <h5>Prêt à disséquer ? 🩺🩻</h5>
            <p>Charge une image et commence ton aventure anatomique !</p>
          </div>
          <canvas id="canvas" style="display: none"></canvas>
        </div>
        <div class="bottom-right-toolbar">
          <button
            class="btn"
            id="undoBtn"
            data-bs-toggle="tooltip"
            data-bs-placement="top"
            title="Annuler"
          >
            <i class="fas fa-undo"></i>
          </button>
          <button
            class="btn"
            id="redoBtn"
            data-bs-toggle="tooltip"
            data-bs-placement="top"
            title="Refaire"
          >
            <i class="fas fa-redo"></i>
          </button>
          <button
            class="btn"
            id="clearAllBtn"
            data-bs-toggle="tooltip"
            data-bs-placement="top"
            title="Supprimer"
          >
            <i class="fas fa-trash"></i>
          </button>
        </div>
      </div>
      <div class="category-panel">
        <button class="btn active" id="cat1" data-category="1">
          Artère Cystique
        </button>
        <button class="btn" id="cat2" data-category="2">Canal Cystique</button>
        <button class="btn" id="cat3" data-category="3">
          Vésicule Biliaire
        </button>
        <button class="btn" id="cat4" data-category="4">Foie</button>
        <button class="btn" id="cat5" data-category="5">Outil</button>
      </div>
    </div>

    <input
      type="file"
      id="imageInput"
      accept="image/jpeg,image/png,image/gif"
      style="display: none"
    />

    <div
      class="modal fade"
      id="tutorialModal"
      tabindex="-1"
      aria-labelledby="tutorialModalLabel"
      aria-hidden="true"
    >
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5
              class="modal-title text-center w-100 fw-bold"
              id="tutorialModalLabel"
            >
              Guide Anatomique 🩺
            </h5>
            <button
              type="button"
              class="btn-close"
              data-bs-dismiss="modal"
              aria-label="Close"
            ></button>
          </div>
          <div class="modal-body">
            <div class="d-flex flex-column gap-3">
              <div class="d-flex align-items-start gap-3">
                <div>
                  <strong>1. Charger une image 📷</strong>
                  <p>
                    Clique sur "Charger" pour importer ton image anatomique.
                  </p>
                </div>
              </div>
              <div class="d-flex align-items-start gap-3">
                <div>
                  <strong>2. Choisir une catégorie 🫀</strong>
                  <p>
                    Sélectionne une structure anatomique dans le panneau de
                    droite.
                  </p>
                </div>
              </div>
              <div class="d-flex align-items-start gap-3">
                <div>
                  <strong>3. Annoter ✍️</strong>
                  <p>
                    Maintiens le clic ou le toucher pour dessiner un masque.
                    Relâche pour finaliser.
                  </p>
                </div>
              </div>
              <div class="d-flex align-items-start gap-3">
                <div>
                  <strong>4. Sauvegarder 💾</strong>
                  <p>
                    Enregistre tes annotations en JSON et JPG pour les partager
                    ou les réutiliser.
                  </p>
                </div>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <div class="form-check">
              <input
                class="form-check-input"
                type="checkbox"
                id="dontShowAgain"
              />
              <label class="form-check-label" for="dontShowAgain"
                >Ne plus afficher au démarrage</label
              >
            </div>
            <button
              type="button"
              class="btn btn-primary"
              data-bs-dismiss="modal"
            >
              C'est parti ! 🚀
            </button>
          </div>
        </div>
      </div>
    </div>

    <div
      class="modal fade"
      id="confirmModal"
      tabindex="-1"
      aria-labelledby="confirmModalLabel"
      aria-hidden="true"
    >
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title text-center w-100" id="confirmModalLabel">
              Confirmation
            </h5>
            <button
              type="button"
              class="btn-close"
              data-bs-dismiss="modal"
              aria-label="Close"
            ></button>
          </div>
          <div class="modal-body">
            <p id="confirmMessage"></p>
          </div>
          <div class="modal-footer">
            <button
              type="button"
              class="btn btn-secondary"
              data-bs-dismiss="modal"
            >
              Annuler
            </button>
            <button type="button" class="btn btn-primary" id="confirmActionBtn">
              Confirmer
            </button>
          </div>
        </div>
      </div>
    </div>

    <div
      class="modal fade"
      id="imageChangeModal"
      tabindex="-1"
      aria-labelledby="imageChangeModalLabel"
      aria-hidden="true"
    >
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5
              class="modal-title text-center w-100"
              id="imageChangeModalLabel"
            >
              Changer d'image
            </h5>
            <button
              type="button"
              class="btn-close"
              data-bs-dismiss="modal"
              aria-label="Close"
            ></button>
          </div>
          <div class="modal-body">
            <p>
              Voulez-vous enregistrer vos annotations avant de charger une
              nouvelle image ?
            </p>
          </div>
          <div class="modal-footer">
            <button
              type="button"
              class="btn btn-secondary"
              data-bs-dismiss="modal"
            >
              Annuler
            </button>
            <button type="button" class="btn btn-primary" id="saveAndChangeBtn">
              Enregistrer et changer
            </button>
            <button
              type="button"
              class="btn btn-primary"
              id="changeWithoutSavingBtn"
            >
              Changer sans enregistrer
            </button>
          </div>
        </div>
      </div>
    </div>

    <div
      class="modal fade"
      id="historyModal"
      tabindex="-1"
      aria-labelledby="historyModalLabel"
      aria-hidden="true"
    >
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title text-center w-100" id="historyModalLabel">
              Historique des images annotées
            </h5>
            <button
              type="button"
              class="btn-close"
              data-bs-dismiss="modal"
              aria-label="Close"
            ></button>
          </div>
          <div class="modal-body">
            <ul class="list-group" id="historyList"></ul>
          </div>
          <div class="modal-footer">
            <button
              type="button"
              class="btn btn-secondary"
              data-bs-dismiss="modal"
            >
              Fermer
            </button>
          </div>
        </div>
      </div>
    </div>

    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
      crossorigin="anonymous"
    ></script>
    <script>
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("/sw.js", { scope: "/" })
            .then((reg) => console.log("Service Worker registered:", reg.scope))
            .catch((err) =>
              console.error("Service Worker registration failed:", err)
            );
        });
      }

      let deferredPrompt;
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const placeholder = document.getElementById("noImagePlaceholder");
      const wrapper = document.querySelector(".canvas-wrapper");
      let image = null;
      const annotations = [];
      let undoneAnnotations = [];
      let currentCategory = 1;
      let maskPoints = [];
      let isDrawing = false;
      let imageId = 1;
      let annotationId = 0;
      let zoomLevel = 1;
      let showAnnotations = true;
      let isSaved = true;
      let isViewOnly = false;
      let sessionAnnotatedImages = localStorage.getItem("lastAnnotatedImage")
        ? [localStorage.getItem("lastAnnotatedImage")]
        : [];
      let prevContainerSize = { width: 0, height: 0 };

      const defaultCategories = {
        1: {
          id: 3,
          name: "cystic_artery",
          color: "rgb(22, 163, 74)",
          supercategory: "anatomy",
          displayName: "Artère Cystique",
          icon: "fa-project-diagram",
        },
        2: {
          id: 4,
          name: "cystic_duct",
          color: "rgb(37, 99, 235)",
          supercategory: "anatomy",
          displayName: "Canal Cystique",
          icon: "fa-water",
        },
        3: {
          id: 5,
          name: "gallbladder",
          color: "rgb(217, 119, 6)",
          supercategory: "anatomy",
          displayName: "Vésicule Biliaire",
          icon: "fa-leaf",
        },
        4: {
          id: 7,
          name: "liver",
          color: "rgb(148, 0, 211)",
          supercategory: "anatomy",
          displayName: "Foie",
          icon: "fa-liver",
        },
        5: {
          id: 6,
          name: "outil",
          color: "rgb(185, 28, 28)",
          supercategory: "tool",
          displayName: "Outil",
          icon: "fa-tools",
        },
      };

      let categories = { ...defaultCategories };

      function hexToRgba(hex, alpha) {
        try {
          hex = hex.replace("#", "");
          const r = parseInt(hex.substring(0, 2), 16);
          const g = parseInt(hex.substring(2, 4), 16);
          const b = parseInt(hex.substring(4, 6), 16);
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        } catch (e) {
          console.error("Error in hexToRgba:", e);
          return `rgba(128, 128, 128, ${alpha})`;
        }
      }

      function showConfirmModal(
        title,
        message,
        confirmCallback,
        cancelCallback
      ) {
        try {
          const modal = new bootstrap.Modal(
            document.getElementById("confirmModal")
          );
          document.getElementById("confirmModalLabel").textContent = title;
          document.getElementById("confirmMessage").textContent = message;
          const confirmBtn = document.getElementById("confirmActionBtn");
          const cancelBtn = document.querySelector(
            "#confirmModal .btn-secondary"
          );

          confirmBtn.replaceWith(confirmBtn.cloneNode(true));
          cancelBtn.replaceWith(cancelBtn.cloneNode(true));

          const newConfirmBtn = document.getElementById("confirmActionBtn");
          const newCancelBtn = document.querySelector(
            "#confirmModal .btn-secondary"
          );

          newConfirmBtn.addEventListener("click", () => {
            confirmCallback();
            modal.hide();
          });

          newCancelBtn.addEventListener("click", () => {
            if (cancelCallback) cancelCallback();
            modal.hide();
          });

          modal.show();
        } catch (e) {
          console.error("Error in showConfirmModal:", e);
        }
      }

      function showImageChangeModal(file) {
        try {
          const modal = new bootstrap.Modal(
            document.getElementById("imageChangeModal")
          );
          const saveAndChangeBtn = document.getElementById("saveAndChangeBtn");
          const changeWithoutSavingBtn = document.getElementById(
            "changeWithoutSavingBtn"
          );
          const cancelBtn = document.querySelector(
            "#imageChangeModal .btn-secondary"
          );

          saveAndChangeBtn.replaceWith(saveAndChangeBtn.cloneNode(true));
          changeWithoutSavingBtn.replaceWith(
            changeWithoutSavingBtn.cloneNode(true)
          );
          cancelBtn.replaceWith(cancelBtn.cloneNode(true));

          const newSaveAndChangeBtn =
            document.getElementById("saveAndChangeBtn");
          const newChangeWithoutSavingBtn = document.getElementById(
            "changeWithoutSavingBtn"
          );
          const newCancelBtn = document.querySelector(
            "#imageChangeModal .btn-secondary"
          );

          newSaveAndChangeBtn.addEventListener("click", () => {
            saveAll();
            checkAndLoadImage(file);
            modal.hide();
          });

          newChangeWithoutSavingBtn.addEventListener("click", () => {
            isSaved = true;
            checkAndLoadImage(file);
            modal.hide();
          });

          newCancelBtn.addEventListener("click", () => {
            modal.hide();
          });

          modal.show();
        } catch (e) {
          console.error("Error in showImageChangeModal:", e);
        }
      }

      function showHistoryModal() {
        try {
          const modal = new bootstrap.Modal(
            document.getElementById("historyModal")
          );
          const historyList = document.getElementById("historyList");
          historyList.innerHTML = "";

          if (sessionAnnotatedImages.length === 0) {
            historyList.innerHTML =
              '<li class="list-group-item">Aucune image annotée dans cette session</li>';
          } else {
            sessionAnnotatedImages.forEach((imageName) => {
              const listItem = document.createElement("li");
              listItem.className = "list-group-item";
              listItem.textContent = imageName;
              listItem.addEventListener("click", () => {
                loadImageFromHistory(imageName);
                modal.hide();
              });
              historyList.appendChild(listItem);
            });
          }

          modal.show();
        } catch (e) {
          console.error("Error in showHistoryModal:", e);
        }
      }

      function loadImageFromHistory(imageName) {
        try {
          const imageInput = document.getElementById("imageInput");
          imageInput.value = "";
          imageInput.click();

          imageInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (file.name !== imageName) return;

            if (!isSaved && (annotations.length > 0 || maskPoints.length > 0)) {
              showImageChangeModal(file);
            } else {
              checkAndLoadImage(file);
            }
          };
        } catch (e) {
          console.error("Error in loadImageFromHistory:", e);
        }
      }

      function checkUnsavedChanges(callback) {
        if (!isSaved && (annotations.length > 0 || maskPoints.length > 0)) {
          showConfirmModal(
            "Modifications non enregistrées",
            "Vous avez des modifications non enregistrées. Voulez-vous enregistrer avant de continuer ?",
            () => {
              saveAll();
              callback();
            },
            () => {
              callback();
            }
          );
        } else {
          callback();
        }
      }

      function setupEventHandlers() {
        try {
          const buttons = {
            undoBtn: () => {
              if (!isViewOnly) {
                undoAnnotation();
                isSaved = false;
              }
            },
            redoBtn: () => {
              if (!isViewOnly) {
                redoAnnotation();
                isSaved = false;
              }
            },
            clearAllBtn: () => {
              if (!isViewOnly) {
                showConfirmModal(
                  "Supprimer toutes les annotations",
                  "Voulez-vous vraiment supprimer toutes les annotations ? Cette action est irréversible.",
                  () => {
                    clearAllAnnotations();
                    isSaved = false;
                  }
                );
              }
            },
            saveBtn: debounce(() => {
              saveAll();
              isSaved = true;
            }, 1000),
            newImageBtn: () => {
              const imageInput = document.getElementById("imageInput");
              if (
                !isSaved &&
                (annotations.length > 0 || maskPoints.length > 0)
              ) {
                showImageChangeModal(imageInput.files[0]);
              } else {
                imageInput.click();
              }
            },
            historyBtn: () => {
              showHistoryModal();
            },
            toggleAnnotationsBtn: toggleAnnotations,
            backBtn: () => {
              checkUnsavedChanges(() => (window.location.href = "index.html"));
            },
            tutorialBtn: () => {
              const tutorialModal = new bootstrap.Modal(
                document.getElementById("tutorialModal")
              );
              tutorialModal.show();
            },
          };

          Object.entries(buttons).forEach(([id, handler]) => {
            const button = document.getElementById(id);
            if (button) {
              console.log(`Attaching listener to button: ${id}`);
              button.replaceWith(button.cloneNode(true));
              const newButton = document.getElementById(id);
              newButton.addEventListener("click", handler);
            } else {
              console.error(`Button with ID ${id} not found`);
            }
          });

          const imageInput = document.getElementById("imageInput");
          if (imageInput) {
            console.log("Attaching listener to imageInput");
            imageInput.replaceWith(imageInput.cloneNode(true));
            const newImageInput = document.getElementById("imageInput");
            newImageInput.addEventListener("change", (e) => {
              if (e.target.files[0]) {
                if (
                  !isSaved &&
                  (annotations.length > 0 || maskPoints.length > 0)
                ) {
                  showImageChangeModal(e.target.files[0]);
                } else {
                  checkAndLoadImage(e.target.files[0]);
                }
              }
            });
          } else {
            console.error("imageInput not found");
          }

          const categoryButtons = document.querySelectorAll(
            ".category-panel button"
          );
          categoryButtons.forEach((button) => {
            const id = button.id;
            console.log(`Attaching listener to category button: ${id}`);
            button.replaceWith(button.cloneNode(true));
            const newButton = document.getElementById(id);
            newButton.addEventListener("click", () => {
              selectCategory(parseInt(newButton.dataset.category));
            });
          });

          const tutorialModalEl = document.getElementById("tutorialModal");
          if (tutorialModalEl) {
            console.log("Attaching listener to tutorialModal");
            tutorialModalEl.addEventListener("hidden.bs.modal", () => {
              console.log("Tutorial modal closed");
              canvas.focus();
              setupCanvasEventListeners();
            });
          }

          const confirmModalEl = document.getElementById("confirmModal");
          if (confirmModalEl) {
            console.log("Attaching listener to confirmModal");
            confirmModalEl.addEventListener("hidden.bs.modal", () => {
              console.log("Confirm modal closed");
              canvas.focus();
              setupCanvasEventListeners();
            });
          }

          ["dragenter", "dragover", "dragleave", "drop"].forEach((event) => {
            wrapper.addEventListener(event, (e) => e.preventDefault());
          });
          wrapper.addEventListener("drop", (e) => {
            const files = e.dataTransfer.files;
            if (files[0]) {
              if (
                !isSaved &&
                (annotations.length > 0 || maskPoints.length > 0)
              ) {
                showImageChangeModal(files[0]);
              } else {
                checkAndLoadImage(files[0]);
              }
            }
          });

          const tooltipTriggerList = document.querySelectorAll(
            '[data-bs-toggle="tooltip"]'
          );
          tooltipTriggerList.forEach((tooltipTriggerEl) => {
            new bootstrap.Tooltip(tooltipTriggerEl);
          });

          if (!localStorage.getItem("tutorialShown")) {
            const tutorialModal = new bootstrap.Modal(
              document.getElementById("tutorialModal")
            );
            tutorialModal.show();
          }

          document
            .getElementById("dontShowAgain")
            .addEventListener("change", (e) => {
              if (e.target.checked) {
                localStorage.setItem("tutorialShown", "true");
              }
            });

          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && maskPoints.length > 0 && !isViewOnly) {
              cancelAnnotation();
              isSaved = false;
            }
          });

          setupCanvasEventListeners();
          setupBackgroundCanvas();
        } catch (e) {
          console.error("Error in setupEventHandlers:", e);
        }
      }

      function setupBackgroundCanvas() {
        try {
          const bgCanvas = document.getElementById("background");
          const bgCtx = bgCanvas.getContext("2d");
          let w,
            h,
            particles = [];

          function randomRange(min, max) {
            return Math.random() * (max - min) + min;
          }

          function initCanvas() {
            w = bgCanvas.width = window.innerWidth;
            h = bgCanvas.height = window.innerHeight;
            particles = [];
            const particleCount = Math.min(50, Math.floor((w * h) / 20000));
            for (let i = 0; i < particleCount; i++) {
              particles.push({
                x: Math.random() * w,
                y: Math.random() * h,
                vx: randomRange(-0.5, 0.5),
                vy: randomRange(-0.5, 0.5),
                r: randomRange(1, 2.5),
                opacity: randomRange(0.3, 0.7),
              });
            }
          }

          function draw() {
            bgCtx.clearRect(0, 0, w, h);
            particles.forEach((p) => {
              bgCtx.beginPath();
              bgCtx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
              bgCtx.fillStyle = `rgba(38, 166, 154, ${p.opacity})`;
              bgCtx.fill();

              p.x += p.vx;
              p.y += p.vy;
              if (p.x < 0 || p.x > w) p.vx *= -1;
              if (p.y < 0 || p.y > h) p.vy *= -1;
            });
            requestAnimationFrame(draw);
          }

          window.addEventListener("resize", initCanvas);
          initCanvas();
          draw();
        } catch (e) {
          console.error("Error in setupBackgroundCanvas:", e);
        }
      }

      function cancelAnnotation() {
        try {
          if (maskPoints.length > 0) {
            maskPoints = [];
            isDrawing = false;
            redrawCanvas();
          }
        } catch (e) {
          console.error("Error in cancelAnnotation:", e);
        }
      }

      function toggleAnnotations() {
        try {
          showAnnotations = !showAnnotations;
          const toggleBtn = document.getElementById("toggleAnnotationsBtn");
          toggleBtn.innerHTML = showAnnotations
            ? '<i class="fas fa-eye"></i>'
            : '<i class="fas fa-eye-slash"></i>';
          redrawCanvas();
        } catch (e) {
          console.error("Error in toggleAnnotations:", e);
        }
      }

      function setupCanvasEventListeners() {
        try {
          canvas.removeEventListener("touchstart", handleTouchStart);
          canvas.removeEventListener("touchmove", handleTouchMove);
          canvas.removeEventListener("touchend", handleTouchEnd);
          canvas.removeEventListener("mousedown", handleMouseDown);
          canvas.removeEventListener("mousemove", handleMouseMove);
          canvas.removeEventListener("mouseup", handleMouseUp);
          canvas.removeEventListener("contextmenu", handleContextMenu);

          if (!isViewOnly) {
            canvas.addEventListener("touchstart", handleTouchStart, {
              passive: false,
            });
            canvas.addEventListener("touchmove", handleTouchMove, {
              passive: false,
            });
            canvas.addEventListener("touchend", handleTouchEnd, {
              passive: false,
            });
            canvas.addEventListener("mousedown", handleMouseDown);
            canvas.addEventListener("mousemove", handleMouseMove);
            canvas.addEventListener("mouseup", handleMouseUp);
            canvas.addEventListener("contextmenu", handleContextMenu);
          }
        } catch (e) {
          console.error("Error in setupCanvasEventListeners:", e);
        }
      }

      function handleContextMenu(e) {
        e.preventDefault();
      }

      function getTransformedPos(clientX, clientY) {
        try {
          if (!image) return { x: 0, y: 0 };
          const rect = canvas.getBoundingClientRect();
          const container = document.querySelector(".canvas-area");
          const containerRect = container.getBoundingClientRect();

          const imgRatio = image.width / image.height;
          const canvasRatio = rect.width / rect.height;
          let imgWidth, imgHeight, offsetX, offsetY;

          if (imgRatio > canvasRatio) {
            imgWidth = rect.width;
            imgHeight = imgWidth / imgRatio;
            offsetX = 0;
            offsetY = (rect.height - imgHeight) / 2;
          } else {
            imgHeight = rect.height;
            imgWidth = imgHeight * imgRatio;
            offsetX = (rect.width - imgWidth) / 2;
            offsetY = 0;
          }

          const relX = clientX - rect.left - offsetX;
          const relY = clientY - rect.top - offsetY;

          if (relX < 0 || relX > imgWidth || relY < 0 || relY > imgHeight) {
            return { x: -1, y: -1 };
          }

          const x = (relX / imgWidth) * image.width;
          const y = (relY / imgHeight) * image.height;

          return {
            x: Math.max(0, Math.min(x, image.width)),
            y: Math.max(0, Math.min(y, image.height)),
          };
        } catch (e) {
          console.error("Error in getTransformedPos:", e);
          return { x: 0, y: 0 };
        }
      }

      function handleTouchStart(e) {
        e.preventDefault();
        if (!image || isViewOnly) return;

        try {
          const touch = e.touches[0];
          const { x, y } = getTransformedPos(touch.clientX, touch.clientY);
          if (x < 0 || y < 0) return;
          if (e.touches.length === 1) {
            isDrawing = true;
            maskPoints = [{ x, y }];
            isSaved = false;
            redrawCanvas();
          }
        } catch (e) {
          console.error("Error in handleTouchStart:", e);
        }
      }

      function handleTouchMove(e) {
        e.preventDefault();
        if (!image || isViewOnly || !isDrawing) return;

        try {
          const touch = e.touches[0];
          const { x, y } = getTransformedPos(touch.clientX, touch.clientY);
          if (x < 0 || y < 0) return;
          const lastPoint = maskPoints[maskPoints.length - 1];
          const distance = Math.sqrt(
            (x - lastPoint.x) ** 2 + (y - lastPoint.y) ** 2
          );
          if (distance > 1) {
            maskPoints.push({ x, y });
            redrawCanvas();
            drawTemporaryMask();
          }
        } catch (e) {
          console.error("Error in handleTouchMove:", e);
        }
      }

      function handleTouchEnd(e) {
        e.preventDefault();
        if (!image || isViewOnly || !isDrawing) return;

        try {
          isDrawing = false;
          finalizeMask();
        } catch (e) {
          console.error("Error in handleTouchEnd:", e);
        }
      }

      function handleMouseDown(e) {
        if (!image || isViewOnly || e.button !== 0) return;

        try {
          const { x, y } = getTransformedPos(e.clientX, e.clientY);
          if (x < 0 || y < 0) return;
          isDrawing = true;
          maskPoints = [{ x, y }];
          isSaved = false;
          redrawCanvas();
        } catch (e) {
          console.error("Error in handleMouseDown:", e);
        }
      }

      function handleMouseMove(e) {
        if (!image || isViewOnly || !isDrawing) return;

        try {
          const { x, y } = getTransformedPos(e.clientX, e.clientY);
          if (x < 0 || y < 0) return;
          const lastPoint = maskPoints[maskPoints.length - 1];
          const distance = Math.sqrt(
            (x - lastPoint.x) ** 2 + (y - lastPoint.y) ** 2
          );
          if (distance > 1) {
            maskPoints.push({ x, y });
            redrawCanvas();
            drawTemporaryMask();
          }
        } catch (e) {
          console.error("Error in handleMouseMove:", e);
        }
      }

      function handleMouseUp(e) {
        if (!image || isViewOnly || !isDrawing) return;

        try {
          isDrawing = false;
          finalizeMask();
        } catch (e) {
          console.error("Error in handleMouseUp:", e);
        }
      }

      function initializeCanvas(img) {
        try {
          const container = document.querySelector(".canvas-area");
          const maxWidth = container.clientWidth;
          const maxHeight = container.clientHeight;
          const scale = Math.min(maxWidth / img.width, maxHeight / img.height);
          canvas.width = img.width * scale;
          canvas.height = img.height * scale;
          canvas.style.display = "block";
          placeholder.style.display = "none";
          zoomLevel = 1;
          canvas.style.transform = `scale(${zoomLevel})`;
          redrawCanvas();
          isSaved = true;
        } catch (e) {
          console.error("Error in initializeCanvas:", e);
        }
      }

      function checkAndLoadImage(file) {
        try {
          if (image && file.name === image.file_name) {
            return;
          }
          if (sessionAnnotatedImages.includes(file.name)) {
            isViewOnly = true;
            loadImage(file);
          } else {
            isViewOnly = false;
            loadImage(file);
          }
        } catch (e) {
          console.error("Error in checkAndLoadImage:", e);
        }
      }

      function loadImage(file) {
        try {
          const progressContainer =
            document.getElementById("progressContainer");
          progressContainer.classList.add("active");

          if (!file.type.startsWith("image/")) {
            progressContainer.classList.remove("active");
            return;
          }

          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.src = e.target.result;
            img.onload = () => {
              setTimeout(
                () => progressContainer.classList.remove("active"),
                300
              );

              annotations.length = 0;
              maskPoints = [];
              isDrawing = false;

              image = {
                file_name: file.name,
                image: img,
                id: imageId++,
                height: img.height,
                width: img.width,
                video_id: 1, // ou générer dynamiquement
                frame_id: null,
                is_det_keyframe: true,
                is_ds_keyframe: true,
                ds: [0.0, 0.0, 0.0],
              };

              initializeCanvas(img);
              showAnnotations = true;
              document.getElementById("toggleAnnotationsBtn").innerHTML =
                '<i class="fas fa-eye"></i>';
              setupCanvasEventListeners();
            };
            img.onerror = () => {
              progressContainer.classList.remove("active");
            };
          };
          reader.onerror = () => {
            progressContainer.classList.remove("active");
          };
          reader.readAsDataURL(file);
        } catch (e) {
          console.error("Error in loadImage:", e);
        }
      }

      function redrawCanvas() {
        try {
          if (!image) return;

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(image.image, 0, 0, canvas.width, canvas.height);

          if (showAnnotations) {
            const labelRects = [];

            annotations.forEach((anno) => {
              const category = categories[anno.category_id];
              const color = category?.color || "rgb(128, 128, 128)";
              ctx.strokeStyle = color;
              ctx.fillStyle = color
                .replace("rgb", "rgba")
                .replace(")", ", 0.2)");
              ctx.lineWidth = 2;

              const scaleX = canvas.width / image.width;
              const scaleY = canvas.height / image.height;
              // Convertir la segmentation polygon back en points pour l'affichage
              const maskPoints = convertSegmentationToPoints(
                anno.segmentation[0]
              );
              const scaledMask = maskPoints.map((point) => ({
                x: point.x * scaleX,
                y: point.y * scaleY,
              }));

              drawMask(scaledMask);
              drawLabel(
                categories[anno.category_id]?.displayName ||
                  "Catégorie supprimée",
                scaledMask,
                anno.category_id,
                labelRects
              );
            });

            if (maskPoints.length > 0 && !isViewOnly) {
              drawTemporaryMask();
            }
          }
        } catch (e) {
          console.error("Error in redrawCanvas:", e);
        }
      }

      function drawLabel(
        text,
        maskPoints,
        categoryId,
        labelRects,
        context = ctx
      ) {
        try {
          const fontSize = 12;
          context.font = `bold ${fontSize}px Inter`;
          context.textBaseline = "bottom";
          const metrics = context.measureText(text);
          const padding = 4;
          const labelWidth = metrics.width + padding * 4;
          const labelHeight = fontSize + padding * 2;
          const offset = 8;

          const maskBounds = {
            minX: Math.min(...maskPoints.map((p) => p.x)),
            maxX: Math.max(...maskPoints.map((p) => p.x)),
            minY: Math.min(...maskPoints.map((p) => p.y)),
            maxY: Math.max(...maskPoints.map((p) => p.y)),
          };

          const startPoint = maskPoints[0];

          const candidates = [
            {
              x: startPoint.x - labelWidth / 2,
              y: startPoint.y - labelHeight - offset,
            },
            { x: startPoint.x - labelWidth / 2, y: startPoint.y + offset },
            {
              x: startPoint.x - labelWidth - offset,
              y: startPoint.y - labelHeight / 2,
            },
            { x: startPoint.x + offset, y: startPoint.y - labelHeight / 2 },
          ];

          let labelX, labelY;
          let foundPosition = false;

          for (const candidate of candidates) {
            const tempX = Math.max(
              padding,
              Math.min(candidate.x, canvas.width - labelWidth)
            );
            const tempY = Math.max(
              padding,
              Math.min(candidate.y, canvas.height - labelHeight)
            );

            const labelRect = {
              x: tempX,
              y: tempY,
              width: labelWidth,
              height: labelHeight,
            };

            const isOverlappingMask =
              labelRect.x < maskBounds.maxX &&
              labelRect.x + labelRect.width > maskBounds.minX &&
              labelRect.y < maskBounds.maxY &&
              labelRect.y + labelRect.height > maskBounds.minY;

            const isOverlappingLabel = labelRects.some(
              (existingRect) =>
                labelRect.x < existingRect.x + existingRect.width &&
                labelRect.x + labelRect.width > existingRect.x &&
                labelRect.y < existingRect.y + existingRect.height &&
                labelRect.y + labelRect.height > existingRect.y
            );

            if (!isOverlappingMask && !isOverlappingLabel) {
              labelX = tempX;
              labelY = tempY;
              foundPosition = true;
              labelRects.push(labelRect);
              break;
            }
          }

          if (!foundPosition) {
            labelX = Math.max(
              padding,
              Math.min(startPoint.x - labelWidth / 2, canvas.width - labelWidth)
            );
            labelY = Math.max(
              padding,
              Math.min(
                startPoint.y - labelHeight - offset,
                canvas.height - labelHeight
              )
            );
            labelRects.push({
              x: labelX,
              y: labelY,
              width: labelWidth,
              height: labelHeight,
            });
          }

          context.fillStyle = "rgba(20, 40, 55, 0.4)";
          context.filter = "blur(10px)";
          context.fillRect(labelX, labelY, labelWidth, labelHeight);
          context.filter = "none";
          context.fillStyle = categories[categoryId]?.color || "#e0f2f1";
          context.fillText(
            text,
            labelX + padding * 2,
            labelY + fontSize + padding
          );
        } catch (e) {
          console.error("Error in drawLabel:", e);
        }
      }

      function drawMask(points, context = ctx) {
        try {
          context.beginPath();
          points.forEach((point, i) => {
            i === 0
              ? context.moveTo(point.x, point.y)
              : context.lineTo(point.x, point.y);
          });
          context.closePath();
          context.fill();
          context.stroke();
        } catch (e) {
          console.error("Error in drawMask:", e);
        }
      }

      function drawTemporaryMask() {
        try {
          if (!maskPoints.length) return;

          const category = categories[currentCategory];
          const color = category?.color || "rgb(128, 128, 128)";
          ctx.strokeStyle = color;
          ctx.fillStyle = color.replace("rgb", "rgba").replace(")", ", 0.2)");
          ctx.lineWidth = 2;

          const scaleX = canvas.width / image.width;
          const scaleY = canvas.height / image.height;

          ctx.beginPath();
          maskPoints.forEach((point, i) => {
            const x = point.x * scaleX;
            const y = point.y * scaleY;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          });
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          const pointSize = 3;
          ctx.fillStyle = color;
          maskPoints.forEach((point) => {
            ctx.beginPath();
            ctx.arc(
              point.x * scaleX,
              point.y * scaleY,
              pointSize / 2,
              0,
              Math.PI * 2
            );
            ctx.fill();
          });
          if (maskPoints.length > 0) {
            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.arc(
              maskPoints[0].x * scaleX,
              maskPoints[0].y * scaleY,
              5,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
        } catch (e) {
          console.error("Error in drawTemporaryMask:", e);
        }
      }

      function finalizeMask() {
        try {
          if (maskPoints.length < 3) {
            maskPoints = [];
            isDrawing = false;
            redrawCanvas();
            return;
          }

          const xs = maskPoints.map((p) => p.x);
          const ys = maskPoints.map((p) => p.y);
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);
          const area = calculatePolygonArea(maskPoints);

          const segmentation = polygonToCocoFormat(maskPoints);

          annotations.push({
            id: annotationId++,
            image_id: image.id,
            category_id: currentCategory,
            bbox: [minX, minY, maxX - minX, maxY - minY],
            area: area,
            segmentation: segmentation,
            iscrowd: 0,
          });

          maskPoints = [];
          isDrawing = false;
          undoneAnnotations = [];
          redrawCanvas();
          isSaved = false;
        } catch (e) {
          console.error("Error in finalizeMask:", e);
        }
      }

      function calculatePolygonArea(points) {
        try {
          let area = 0;
          for (let i = 0; i < points.length; i++) {
            const j = (i + 1) % points.length;
            area += points[i].x * points[j].y;
            area -= points[j].x * points[i].y;
          }
          return Math.abs(area / 2);
        } catch (e) {
          console.error("Error in calculatePolygonArea:", e);
          return 0;
        }
      }

      function polygonToCocoFormat(maskPoints) {
        try {
          // Convertir les points en format COCO: [x1, y1, x2, y2, ..., xn, yn]
          const segmentation = [];
          maskPoints.forEach((point) => {
            segmentation.push(point.x);
            segmentation.push(point.y);
          });
          return [segmentation]; // Array de arrays pour compatibilité COCO
        } catch (e) {
          console.error("Error in polygonToCocoFormat:", e);
          return [[]];
        }
      }

      function convertSegmentationToPoints(segmentation) {
        try {
          const points = [];
          for (let i = 0; i < segmentation.length; i += 2) {
            points.push({
              x: segmentation[i],
              y: segmentation[i + 1],
            });
          }
          return points;
        } catch (e) {
          console.error("Error in convertSegmentationToPoints:", e);
          return [];
        }
      }

      function undoAnnotation() {
        try {
          const lastAnnotation = annotations.pop();
          if (lastAnnotation) {
            undoneAnnotations.push(lastAnnotation);
            redrawCanvas();
            isSaved = false;
          }
        } catch (e) {
          console.error("Error in undoAnnotation:", e);
        }
      }

      function redoAnnotation() {
        try {
          const lastUndone = undoneAnnotations.pop();
          if (lastUndone) {
            annotations.push(lastUndone);
            redrawCanvas();
            isSaved = false;
          }
        } catch (e) {
          console.error("Error in redoAnnotation:", e);
        }
      }

      function clearAllAnnotations() {
        try {
          if (annotations.length === 0) return;
          annotations.forEach((anno) => undoneAnnotations.push(anno));
          annotations.length = 0;
          maskPoints = [];
          isDrawing = false;
          redrawCanvas();
          isSaved = false;
        } catch (e) {
          console.error("Error in clearAllAnnotations:", e);
        }
      }

      function selectCategory(categoryId) {
        try {
          if (!categories[categoryId]) return;
          currentCategory = categoryId;
          document.querySelectorAll(".category-panel button").forEach((btn) => {
            btn.classList.remove("active");
          });
          const button = document.getElementById(`cat${categoryId}`);
          if (button) {
            button.classList.add("active");
          }
          isSaved = false;
        } catch (e) {
          console.error("Error in selectCategory:", e);
        }
      }

function saveAll() {
  try {
    if (!image) return;

    const baseFileName = image.file_name.split(".")[0];
    const outputFileName = `${baseFileName}_annotated`;

    const imageForJson = {
      file_name: image.file_name,
      height: image.height,
      width: image.width,
      id: image.id,
      video_id: image.video_id,
      frame_id: image.frame_id,
      is_det_keyframe: image.is_det_keyframe,
      is_ds_keyframe: image.is_ds_keyframe,
      ds: image.ds,
    };

    const jsonData = {
      images: [imageForJson],
      annotations: annotations,
      categories: Object.values(categories).map((cat) => ({
        id: cat.id,
        name: cat.name,
        supercategory: cat.supercategory,
      })),
    };

    const jsonStr = JSON.stringify(jsonData, null, 2);
    const jsonBlob = new Blob([jsonStr], { type: "application/json" });
    const jsonUrl = URL.createObjectURL(jsonBlob);
    const jsonLink = document.createElement("a");
    jsonLink.href = jsonUrl;
    jsonLink.download = `${outputFileName}.json`;
    jsonLink.click();
    URL.revokeObjectURL(jsonUrl);

    if (!sessionAnnotatedImages.includes(image.file_name)) {
      sessionAnnotatedImages.push(image.file_name);
      localStorage.setItem("lastAnnotatedImage", image.file_name);
    }

    isSaved = true;
  } catch (e) {
    console.error("Error in saveAll:", e);
  }
}

      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      function handleResize() {
        try {
          const container = document.querySelector(".canvas-area");
          const currentSize = {
            width: container.clientWidth,
            height: container.clientHeight,
          };
          if (
            image &&
            (Math.abs(currentSize.width - prevContainerSize.width) > 1 ||
              Math.abs(currentSize.height - prevContainerSize.height) > 1)
          ) {
            initializeCanvas(image.image);
            prevContainerSize = currentSize;
          }
          const bgCanvas = document.getElementById("background");
          if (bgCanvas) {
            bgCanvas.width = window.innerWidth;
            bgCanvas.height = window.innerHeight;
          }
        } catch (e) {
          console.error("Error in handleResize:", e);
        }
      }

      window.addEventListener("resize", debounce(handleResize, 200));
      setupEventHandlers();
    </script>
  </body>
</html>
