<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Anatomy Annotator</title>
    <!-- Métadonnées et icônes -->
    <meta name="theme-color" content="#0A1A3A" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta
      name="description"
      content="Une application pour annoter des images anatomiques avec des masques et des catégories prédéfinies."
    />
    <link
      rel="apple-touch-icon"
      href="https://placehold.co/180x180/0A1A3A/FFFFFF?text=AA"
      sizes="180x180"
      type="image/png"
    />
    <link
      rel="icon"
      href="https://placehold.co/48x48/0A1A3A/FFFFFF?text=AA"
      sizes="48x48"
      type="image/png"
    />

    <!-- Polices et icônes -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
      rel="stylesheet"
      crossorigin="anonymous"
    />

    <style>
      /* --- Variables CSS Globales --- */
      :root {
        --color-background: #000000;
        --color-text: #eaeaea;
        --color-text-muted: #a0a0a0;
        --gradient-primary: linear-gradient(135deg, #ff7d12, #fb3aa2, #2997ff);
        --glow-color: rgba(251, 58, 162, 0.3);
        --border-color-hover: #fb3aa2;
        --glass-bg: rgba(15, 15, 20, 0.5);
        --glass-blur: blur(12px);
        --border-color: rgba(255, 255, 255, 0.1);
      }

      /* --- Réinitialisation et Styles de Base --- */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html,
      body {
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        font-family: "Inter", sans-serif;
        background-color: var(--color-background);
        color: var(--color-text);
        -webkit-tap-highlight-color: transparent;
      }

      /* --- Arrière-plan Animé --- */
      #constellation-canvas {
        position: fixed;
        inset: 0;
        z-index: -1;
        opacity: 0.6;
      }

      /* --- En-tête --- */
      .top-header {
        position: fixed;
        top: 15px;
        left: 20px;
        z-index: 10;
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--color-text-muted);
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .top-header .app-title {
        background-image: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        font-weight: 600;
      }

      /* --- Conteneur Principal --- */
      .main-container {
        display: flex;
        gap: 1.5rem;
        padding: 60px 1.5rem 1.5rem;
        height: 100%;
        width: 100%;
        align-items: flex-start;
        justify-content: center;
      }

      /* --- Colonne du Canvas --- */
      .canvas-column {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        height: 100%;
        max-width: 1200px;
        min-height: 0;
      }
      .canvas-wrapper {
        flex-grow: 1;
        position: relative;
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        border: 1px solid var(--border-color);
        border-radius: 16px;
        padding: 0.75rem;
        display: flex;
        min-height: 0;
      }
      .canvas-area {
        position: relative;
        width: 100%;
        height: 100%;
        border-radius: 8px;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #canvas {
        max-width: 100%;
        max-height: 100%;
        cursor: crosshair;
        display: none;
        touch-action: none;
      }
      #noImagePlaceholder {
        text-align: center;
        color: var(--color-text-muted);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      #noImagePlaceholder h5 {
        font-size: 1.1rem;
        font-weight: 500;
        color: var(--color-text);
        margin-bottom: 0.5rem;
      }

      /* --- Barres d'outils --- */
      .toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.6rem;
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        border: 1px solid var(--border-color);
        border-radius: 16px;
      }
      .toolbar-group {
        display: flex;
        gap: 0.6rem;
        align-items: center; /* Alignement vertical pour le badge */
      }
      .toolbar-btn {
        width: 42px;
        height: 42px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid var(--border-color);
        color: #ffffff;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .toolbar-btn:hover {
        border-color: var(--border-color-hover);
        background: rgba(255, 255, 255, 0.1);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px var(--glow-color);
      }
      .toolbar-btn.active {
        background-image: var(--gradient-primary);
        color: #ffffff;
        border-color: transparent;
        box-shadow: 0 0 15px var(--glow-color);
      }
      .toolbar-btn.disabled {
        opacity: 0.5;
        cursor: not-allowed;
        pointer-events: none;
      }
      .bottom-toolbar {
        position: absolute;
        bottom: 1.5rem;
        right: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        z-index: 5;
      }
      .read-only-badge {
        background-color: #ffcc00;
        color: #333;
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 0.7em;
        font-weight: 700;
        display: none;
        align-items: center;
        gap: 5px;
      }
      .read-only-badge.active {
        display: flex;
      }

      /* --- Panneau de Catégories --- */
      .category-panel {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        padding: 1rem;
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        border: 1px solid var(--border-color);
        border-radius: 16px;
        width: 260px;
        flex-shrink: 0;
      }
      .category-btn {
        font-family: "Inter", sans-serif;
        font-weight: 500;
        font-size: 0.9rem;
        text-align: left;
        color: var(--color-text);
        padding: 0.8rem 1.2rem;
        border-radius: 10px;
        background-color: rgba(255, 255, 255, 0.05);
        border: 1px solid var(--border-color);
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .category-btn:hover {
        transform: translateY(-2px);
        filter: brightness(1.2);
        border-color: rgba(255, 255, 255, 0.2);
      }
      .category-btn.active {
        color: white;
        border-color: transparent;
        box-shadow: 0 0 15px var(--glow-color);
      }
      /* Couleurs spécifiques par catégorie */
      #cat3.active {
        background-image: linear-gradient(135deg, #ff3333, #cc0000);
      }
      #cat4.active {
        background-image: linear-gradient(135deg, #33cc33, #008000);
      }
      #cat5.active {
        background-image: linear-gradient(135deg, #027541, #005a32);
      }
      #cat7.active {
        background-image: linear-gradient(135deg, #9f33ff, #7e00d1);
      }
      #cat6.active {
        background-image: linear-gradient(135deg, #b3b3b3, #808080);
      }
      #cat8.active {
        background-image: linear-gradient(135deg, #ff9933, #d97506);
      }

      /* --- Modales --- */
      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(8px); /* Blur réduit */
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .modal-overlay.active {
        opacity: 1;
        pointer-events: all;
      }
      /* Assurez-vous que confirmModal est au-dessus de tout le reste */
      #confirmModal.modal-overlay,
      #imageChangeModal.modal-overlay {
        z-index: 1002;
      }
      .modal-content {
        background: var(--glass-bg);
        border: 1px solid var(--border-color);
        border-radius: 16px;
        padding: 1.5rem;
        width: 90%;
        max-width: 500px;
        transform: scale(0.95);
        transition: transform 0.3s ease;
        color: var(--color-text);
        display: flex;
        flex-direction: column;
        max-height: 80vh;
      }
      .modal-overlay.active .modal-content {
        transform: scale(1);
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        flex-shrink: 0;
      }
      .modal-title {
        font-size: 1.2rem;
        font-weight: 600;
      }
      .modal-body {
        margin-bottom: 1.5rem;
        color: var(--color-text-muted);
        line-height: 1.6;
        overflow-y: auto;
        flex-grow: 1;
      }
      .modal-body strong {
        color: var(--color-text);
      }
      .modal-footer {
        display: flex;
        justify-content: flex-end;
        gap: 0.75rem;
        flex-shrink: 0;
      }
      .btn-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        color: var(--color-text-muted);
        cursor: pointer;
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      .btn-close:hover {
        opacity: 1;
      }
      .btn {
        padding: 0.6rem 1.2rem;
        border-radius: 8px;
        font-weight: 500;
        border: 1px solid transparent;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .btn-primary {
        background-image: var(--gradient-primary);
        color: white;
      }
      .btn-primary:hover {
        filter: brightness(1.2);
        box-shadow: 0 0 15px var(--glow-color);
      }
      .btn-secondary {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.2);
        color: var(--color-text);
      }
      .btn-secondary:hover {
        background: rgba(255, 255, 255, 0.15);
      }

      /* Styles de l'historique amélioré */
      #historyList {
        list-style: none;
        padding: 0;
      }
      .history-item {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 10px;
        border-bottom: 1px solid var(--border-color);
        cursor: pointer;
        transition: background-color 0.2s;
        border-radius: 8px;
      }
      .history-item:hover {
        background-color: rgba(255, 255, 255, 0.05);
      }
      .history-item-thumbnail {
        width: 80px;
        height: 60px;
        object-fit: cover;
        border-radius: 6px;
        flex-shrink: 0;
      }
      .history-item-info {
        flex-grow: 1;
        font-size: 0.9rem;
      }
      .history-item-info span {
        display: block;
      }
      .history-item-info .filename {
        font-weight: 600;
        color: var(--color-text);
      }
      .history-item-info .details {
        font-size: 0.8rem;
      }
      .history-item-delete {
        color: var(--color-text-muted);
        cursor: pointer;
        transition: color 0.2s;
        font-size: 1rem;
        padding: 5px;
      }
      .history-item-delete:hover {
        color: #ff5555;
      }

      /* Message d'info/erreur général */
      .message-box {
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 20px;
        border-radius: 8px;
        z-index: 1003; /* Au-dessus des modales */
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s, visibility 0.3s;
        font-size: 0.9rem;
        text-align: center;
      }
      .message-box.active {
        opacity: 1;
        visibility: visible;
      }

      /* Message d'absence d'annotations (nouveau style) */
      .no-annotation-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7); /* Fond semi-transparent foncé */
        backdrop-filter: blur(5px); /* Fond flou */
        color: white;
        padding: 20px 30px;
        border-radius: 12px;
        font-size: 1.5rem; /* Police plus grande */
        font-weight: bold;
        text-align: center;
        pointer-events: none; /* Permet aux clics de passer à travers si besoin */
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s, visibility 0.3s;
        z-index: 50; /* Au-dessus du canvas mais en dessous des modales principales */
      }
      .no-annotation-message.active {
        opacity: 1;
        visibility: visible;
      }

      /* --- Indicateur de Progression --- */
      .progress-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(4px);
        z-index: 1001;
        display: none;
        align-items: center;
        justify-content: center;
      }
      .progress-overlay.active {
        display: flex;
      }
      .progress-spinner {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid var(--border-color-hover);
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        100% {
          transform: rotate(360deg);
        }
      }

      /* --- Responsive --- */
      @media (max-width: 1024px) {
        .main-container {
          flex-direction: column;
          padding: 60px 1rem 1rem;
        }
        .category-panel {
          width: 100%;
          flex-direction: row;
          flex-wrap: wrap;
          max-height: 25vh;
          overflow-y: auto;
        }
        .category-btn {
          flex-grow: 1;
          text-align: center;
        }
        .bottom-toolbar {
          flex-direction: row;
          bottom: 1rem;
          right: 1rem;
        }
      }
      @media (max-width: 768px) {
        .top-header {
          font-size: 0.8rem;
          top: 10px;
          left: 10px;
        }
        .main-container {
          padding: 50px 0.5rem 0.5rem;
          gap: 1rem;
        }
        .toolbar {
          padding: 0.4rem;
        }
        .toolbar-btn {
          width: 38px;
          height: 38px;
          font-size: 1rem;
        }
        .category-panel {
          padding: 0.75rem;
          gap: 0.5rem;
        }
        .category-btn {
          padding: 0.6rem 0.8rem;
          font-size: 0.8rem;
        }
        .bottom-toolbar {
          bottom: 0.75rem;
          right: 0.75rem;
          gap: 0.5rem;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="constellation-canvas"></canvas>
    <div class="top-header">
      <span class="app-title">Anatomy Annotator</span>
      <span class="brand">by Vioo AI</span>
    </div>

    <div class="progress-overlay" id="progressOverlay">
      <div class="progress-spinner"></div>
    </div>

    <div class="main-container">
      <!-- Colonne principale avec le canvas et les outils -->
      <div class="canvas-column">
        <div class="toolbar">
          <div class="toolbar-group">
            <button
              class="toolbar-btn"
              id="newImageBtn"
              title="Charger une image"
            >
              <i class="fas fa-download"></i>
            </button>
            <button
              class="toolbar-btn"
              id="saveBtn"
              title="Enregistrer les annotations"
            >
              <i class="fas fa-save"></i>
            </button>
            <button class="toolbar-btn" id="historyBtn" title="Historique">
              <i class="fas fa-history"></i>
            </button>
            <button
              class="toolbar-btn"
              id="toggleAnnotationsBtn"
              title="Afficher/Masquer les annotations"
            >
              <i class="fas fa-eye"></i>
            </button>
            <span class="read-only-badge" id="readOnlyBadge">
              <i class="fas fa-lock"></i> LECTURE SEULE
            </span>
          </div>
          <div class="toolbar-group">
            <button class="toolbar-btn" id="tutorialBtn" title="Aide">
              <i class="fas fa-question-circle"></i>
            </button>
            <button class="toolbar-btn" id="backBtn" title="Retour">
              <i class="fas fa-arrow-left"></i>
            </button>
          </div>
        </div>

        <div class="canvas-wrapper">
          <div id="noAnnotationMessage" class="no-annotation-message">
            Pas d'annotations. Dessinez pour enregistrer !
          </div>
          <div class="canvas-area">
            <div id="noImagePlaceholder">
              <h5>Prêt à disséquer ?</h5>
              <p>Chargez une image pour commencer.</p>
            </div>
            <canvas id="canvas"></canvas>
          </div>
          <div class="bottom-toolbar">
            <button class="toolbar-btn" id="undoBtn" title="Annuler (Ctrl+Z)">
              <i class="fas fa-undo"></i>
            </button>
            <button class="toolbar-btn" id="redoBtn" title="Refaire (Ctrl+Y)">
              <i class="fas fa-redo"></i>
            </button>
            <button class="toolbar-btn" id="clearAllBtn" title="Tout effacer">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        </div>
      </div>

      <!-- Panneau des catégories -->
      <div class="category-panel">
        <button class="category-btn" id="cat3" data-category="3">
          Artère Cystique
        </button>
        <button class="category-btn" id="cat4" data-category="4">
          Canal Cystique
        </button>
        <button class="category-btn" id="cat5" data-category="5">
          Vésicule Biliaire
        </button>
        <button class="category-btn" id="cat7" data-category="7">Foie</button>
        <button class="category-btn" id="cat6" data-category="6">Outil</button>
        <button class="category-btn" id="cat8" data-category="8">
          Voie Biliaire Principale
        </button>
      </div>
    </div>

    <!-- Input caché pour le chargement de fichier -->
    <input type="file" id="imageInput" accept="image/*" style="display: none" />

    <!-- Modales -->
    <div class="modal-overlay" id="tutorialModal">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Instructions</h5>
          <button class="btn-close" data-dismiss="modal">&times;</button>
        </div>
        <div class="modal-body">
          <p>
            <strong>1. Charger :</strong> Importez une image via
            <i class="fas fa-download"></i> ou par glisser-déposer.
          </p>
          <p>
            <strong>2. Choisir :</strong> Sélectionnez une catégorie
            d'annotation sur la droite.
          </p>
          <p>
            <strong>3. Annoter :</strong> Maintenez le clic ou le toucher pour
            dessiner le contour. Relâchez pour finaliser.
          </p>
          <p>
            <strong>4. Gérer :</strong> Utilisez les outils
            <i class="fas fa-undo"></i>, <i class="fas fa-redo"></i>, et
            <i class="fas fa-trash"></i> pour modifier vos annotations.
          </p>
          <p>
            <strong>5. Sauvegarder :</strong> Enregistrez votre travail via
            <i class="fas fa-save"></i>.
          </p>
        </div>
        <div class="modal-footer">
          <button class="btn btn-primary" data-dismiss="modal">
            Compris !
          </button>
        </div>
      </div>
    </div>

    <div class="modal-overlay" id="confirmModal">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="confirmModalLabel">Confirmation</h5>
          <button class="btn-close" data-dismiss="modal">&times;</button>
        </div>
        <div class="modal-body"><p id="confirmMessage"></p></div>
        <div class="modal-footer">
          <button class="btn btn-secondary" data-dismiss="modal">
            Annuler
          </button>
          <button class="btn btn-primary" id="confirmActionBtn">
            Confirmer
          </button>
        </div>
      </div>
    </div>

    <div class="modal-overlay" id="imageChangeModal">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Changer d'image</h5>
          <button class="btn-close" data-dismiss="modal">&times;</button>
        </div>
        <div class="modal-body">
          <p>
            Voulez-vous enregistrer les annotations actuelles avant de continuer
            ?
          </p>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" data-dismiss="modal">
            Annuler
          </button>
          <button class="btn btn-primary" id="saveAndChangeBtn">
            Enregistrer et changer
          </button>
          <button class="btn btn-primary" id="changeWithoutSavingBtn">
            Changer sans enregistrer
          </button>
        </div>
      </div>
    </div>

    <div class="modal-overlay" id="historyModal">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Historique des annotations</h5>
          <button class="btn-close" data-dismiss="modal">&times;</button>
        </div>
        <div class="modal-body"><ul id="historyList"></ul></div>
        <div class="modal-footer">
          <button class="btn btn-secondary" id="clearHistoryBtn">
            Vider l'historique
          </button>
          <button class="btn btn-primary" data-dismiss="modal">Fermer</button>
        </div>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // --- SÉLECTEURS DU DOM ---
        // Centralisation de tous les éléments DOM pour un accès plus rapide et un code plus court.
        const els = {
          canvas: document.getElementById("canvas"),
          placeholder: document.getElementById("noImagePlaceholder"),
          constellationCanvas: document.getElementById("constellation-canvas"),
          progressOverlay: document.getElementById("progressOverlay"),
          imageInput: document.getElementById("imageInput"),
          readOnlyBadge: document.getElementById("readOnlyBadge"),
          noAnnotationMessage: document.getElementById("noAnnotationMessage"),
          tutorialModal: document.getElementById("tutorialModal"),
          confirmModal: document.getElementById("confirmModal"),
          imageChangeModal: document.getElementById("imageChangeModal"),
          historyModal: document.getElementById("historyModal"),
          confirmModalLabel: document.getElementById("confirmModalLabel"),
          confirmMessage: document.getElementById("confirmMessage"),
          confirmActionBtn: document.getElementById("confirmActionBtn"),
          saveAndChangeBtn: document.getElementById("saveAndChangeBtn"),
          changeWithoutSavingBtn: document.getElementById(
            "changeWithoutSavingBtn"
          ),
          historyList: document.getElementById("historyList"),
          clearHistoryBtn: document.getElementById("clearHistoryBtn"),
          newImageBtn: document.getElementById("newImageBtn"),
          saveBtn: document.getElementById("saveBtn"),
          historyBtn: document.getElementById("historyBtn"),
          toggleAnnotationsBtn: document.getElementById("toggleAnnotationsBtn"),
          tutorialBtn: document.getElementById("tutorialBtn"),
          undoBtn: document.getElementById("undoBtn"),
          redoBtn: document.getElementById("redoBtn"),
          clearAllBtn: document.getElementById("clearAllBtn"),
        };

        const ctx = els.canvas.getContext("2d", { willReadFrequently: true });
        const canvasArea = document.querySelector(".canvas-area");

        // --- ÉTAT GLOBAL DE L'APPLICATION ---
        let image = null;
        const annotations = [];
        let undoneAnnotations = [];
        let currentCategory = 3;
        let maskPoints = [];
        let isDrawing = false;
        let showAnnotations = true;
        let isSaved = true;
        let isViewOnly = false;
        let currentImageRenderInfo = { x: 0, y: 0, width: 0, height: 0 };

        const CATEGORIES = {
          3: {
            id: 3,
            name: "cystic_artery",
            color: "rgb(255, 51, 51)",
            supercategory: "anatomy",
            displayName: "Artère Cystique",
          },
          4: {
            id: 4,
            name: "cystic_duct",
            color: "rgb(51, 204, 51)",
            supercategory: "anatomy",
            displayName: "Canal Cystique",
          },
          5: {
            id: 5,
            name: "gallbladder",
            color: "rgb(0, 90, 50)",
            supercategory: "anatomy",
            displayName: "Vésicule Biliaire",
          },
          6: {
            id: 6,
            name: "tool",
            color: "rgb(179, 179, 179)",
            supercategory: "tool",
            displayName: "Outil",
          },
          7: {
            id: 7,
            name: "liver",
            color: "rgb(159, 51, 255)",
            supercategory: "anatomy",
            displayName: "Foie",
          },
          8: {
            id: 8,
            name: "common_bile_duct",
            color: "rgb(255, 153, 51)",
            supercategory: "anatomy",
            displayName: "Voie Biliaire Principale",
          },
        };

        // --- FONCTIONS UTILITAIRES ---
        const debounce = (func, wait) => {
          let timeout;
          return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
          };
        };

        const setProgress = (active) =>
          els.progressOverlay.classList.toggle("active", active);

        const showNoAnnotationMessage = (duration = 3000) => {
          els.noAnnotationMessage.classList.add("active");
          setTimeout(() => {
            els.noAnnotationMessage.classList.remove("active");
          }, duration);
        };

        // --- ARRIÈRE-PLAN ANIMÉ ---
        // La logique d'arrière-plan animée est déjà encapsulée et ne nécessite pas de modifications d'optimisation supplémentaires.
        (() => {
          const bgCtx = els.constellationCanvas.getContext("2d");
          let stars = [],
            animationFrameId;

          const setup = () => {
            els.constellationCanvas.width = window.innerWidth;
            els.constellationCanvas.height = window.innerHeight;
            stars = [];
            const starCount = Math.min(
              150,
              (window.innerWidth * window.innerHeight) / 10000
            );
            for (let i = 0; i < starCount; i++) {
              stars.push({
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                radius: Math.random() * 1.6 + 0.8,
                vx: (Math.random() - 0.5) * 0.1,
                vy: (Math.random() - 0.5) * 0.1,
                opacity: Math.random() * 0.6 + 0.3,
              });
            }
          };
          const draw = () => {
            bgCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            stars.forEach((star) => {
              bgCtx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
              bgCtx.beginPath();
              bgCtx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
              bgCtx.fill();
              star.x += star.vx;
              star.y += star.vy;
              if (star.x < 0 || star.x > window.innerWidth) star.vx *= -1;
              if (star.y < 0 || star.y > window.innerHeight) star.vy *= -1;
            });
            animationFrameId = requestAnimationFrame(draw);
          };
          window.addEventListener("resize", debounce(setup, 200));
          setup();
          draw();
        })();

        // --- GESTION DES MODALES ---
        const setupModals = () => {
          document.querySelectorAll('[data-dismiss="modal"]').forEach((btn) => {
            btn.addEventListener("click", () =>
              btn.closest(".modal-overlay").classList.remove("active")
            );
          });
        };
        const toggleModal = (modalId, show) =>
          document.getElementById(modalId).classList.toggle("active", show);

        const showConfirmModal = (title, message, confirmCallback) => {
          els.confirmModalLabel.textContent = title;
          els.confirmMessage.textContent = message;
          const confirmBtn = els.confirmActionBtn;
          // Clonage du bouton pour supprimer les anciens écouteurs d'événements et éviter les déclenchements multiples.
          const newConfirmBtn = confirmBtn.cloneNode(true);
          confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

          newConfirmBtn.addEventListener(
            "click",
            () => {
              confirmCallback();
              toggleModal("confirmModal", false);
            },
            { once: true } // L'écouteur est automatiquement supprimé après un seul déclenchement.
          );
          toggleModal("confirmModal", true);
        };

        // --- GESTION DE L'HISTORIQUE ---
        const getHistory = () =>
          JSON.parse(localStorage.getItem("annotatedImageHistory")) || [];
        const saveHistory = (history) => {
          // Limite l'historique aux 10 dernières entrées pour optimiser le stockage.
          if (history.length > 10) history = history.slice(-10);
          localStorage.setItem(
            "annotatedImageHistory",
            JSON.stringify(history)
          );
        };
        const deleteHistoryEntry = (timestamp) => {
          showConfirmModal(
            "Supprimer l'entrée",
            "Voulez-vous vraiment supprimer cette entrée de l'historique ?",
            () => {
              let history = getHistory().filter(
                (item) => item.timestamp !== timestamp
              );
              saveHistory(history);
              showHistoryModal(); // Rafraîchit l'affichage de la modale après suppression.
            }
          );
        };
        const clearAllHistory = () => {
          showConfirmModal(
            "Vider l'historique",
            "Voulez-vous vraiment supprimer tout l'historique ? Cette action est irréversible.",
            () => {
              localStorage.removeItem("annotatedImageHistory");
              showHistoryModal(); // Rafraîchit l'affichage de la modale après vidage.
            }
          );
        };
        const showHistoryModal = () => {
          els.historyList.innerHTML = "";
          const history = getHistory();
          els.clearHistoryBtn.style.display =
            history.length > 0 ? "block" : "none";

          if (history.length === 0) {
            els.historyList.innerHTML =
              "<li>Aucune image dans l'historique.</li>";
          } else {
            // Afficher les éléments les plus récents en premier.
            history.reverse().forEach((entry) => {
              const li = document.createElement("li");
              li.className = "history-item";
              li.innerHTML = `
                        <img src="${
                          entry.imageData
                        }" class="history-item-thumbnail" alt="Aperçu"/>
                        <div class="history-item-info">
                            <span class="filename">${entry.fileName}</span>
                            <span class="details">${
                              entry.annotations.length
                            } annotation(s) - ${new Date(
                entry.timestamp
              ).toLocaleString()}</span>
                        </div>
                        <i class="fas fa-trash history-item-delete" title="Supprimer cette entrée"></i>
                    `;
              li.querySelector(".history-item-delete").addEventListener(
                "click",
                (e) => {
                  e.stopPropagation(); // Empêche l'événement de clic du li de se déclencher.
                  deleteHistoryEntry(entry.timestamp);
                }
              );
              li.addEventListener("click", () =>
                checkUnsavedChanges(() => {
                  loadImageFromHistory(entry);
                  toggleModal("historyModal", false);
                })
              );
              els.historyList.appendChild(li);
            });
          }
          toggleModal("historyModal", true);
        };

        // --- LOGIQUE DU CANVAS ET DES ANNOTATIONS ---
        const updateUIState = () => {
          const hasImage = !!image;
          // Les outils d'annotation sont désactivés en mode lecture seule.
          const canAnnotate = hasImage && !isViewOnly;

          els.canvas.style.display = hasImage ? "block" : "none";
          els.placeholder.style.display = hasImage ? "none" : "flex";

          // Contrôle l'état des boutons liés à l'annotation et à la sauvegarde.
          ["undoBtn", "redoBtn", "clearAllBtn", "saveBtn"].forEach((id) => {
            const btn = els[id];
            btn.disabled = !canAnnotate;
            btn.classList.toggle("disabled", !canAnnotate);
          });
          // Contrôle l'état des boutons de catégorie.
          document.querySelectorAll(".category-btn").forEach((btn) => {
            btn.disabled = !canAnnotate;
            btn.classList.toggle("disabled", !canAnnotate);
          });

          // Affiche ou masque le badge "LECTURE SEULE".
          els.readOnlyBadge.classList.toggle("active", isViewOnly);

          // Si en mode lecture seule, désélectionne toute catégorie active.
          if (isViewOnly) {
            document
              .querySelectorAll(".category-btn.active")
              .forEach((b) => b.classList.remove("active"));
          } else if (hasImage) {
            // Sinon, sélectionne la catégorie actuelle si une image est chargée.
            selectCategory(currentCategory);
          }
        };

        const resetStateForNewImage = () => {
          annotations.length = 0;
          undoneAnnotations.length = 0;
          maskPoints = [];
          isDrawing = false;
          isSaved = true;
          isViewOnly = false; // Réinitialise le mode lecture seule.
        };

        const loadImage = (file) => {
          if (!file || !file.type.startsWith("image/")) return;
          setProgress(true);
          const reader = new FileReader();
          reader.onload = (e) => {
            const imgElement = new Image();
            imgElement.onload = () => {
              // Création d'un canvas temporaire pour redimensionner l'image
              const tempCanvas = document.createElement("canvas");
              const tempCtx = tempCanvas.getContext("2d");
              const targetWidth = 854;
              const targetHeight = 480;

              tempCanvas.width = targetWidth;
              tempCanvas.height = targetHeight;

              // Dessine l'image originale sur le canvas temporaire avec les nouvelles dimensions
              tempCtx.drawImage(imgElement, 0, 0, targetWidth, targetHeight);

              // Récupère la Data URL de l'image redimensionnée
              const resizedDataURL = tempCanvas.toDataURL(file.type);

              const resizedImgElement = new Image();
              resizedImgElement.onload = () => {
                resetStateForNewImage();
                image = {
                  file_name: file.name,
                  dataURL: resizedDataURL,
                  image: resizedImgElement,
                  id: Date.now(),
                  height: targetHeight,
                  width: targetWidth,
                  annotationIndex: 0,
                };
                initializeCanvas();
                updateUIState();
                setProgress(false);
              };
              resizedImgElement.src = resizedDataURL;
            };
            imgElement.src = e.target.result;
          };
          reader.readAsDataURL(file);
        };

        const loadImageFromHistory = (historyEntry) => {
          setProgress(true);
          const imgElement = new Image();
          imgElement.onload = () => {
            resetStateForNewImage();
            isViewOnly = true; // Définit le mode lecture seule.
            image = {
              file_name: historyEntry.fileName,
              dataURL: historyEntry.imageData,
              image: imgElement,
              id: historyEntry.imageId,
              height: imgElement.height,
              width: imgElement.width,
            };
            // Charge une copie profonde des annotations pour ne pas modifier l'historique d'origine.
            annotations.push(
              ...JSON.parse(JSON.stringify(historyEntry.annotations))
            );
            // Calcule le prochain index d'annotation pour éviter les conflits si l'on sort du mode lecture seule.
            image.annotationIndex =
              annotations.reduce(
                (max, anno) => Math.max(max, anno.id % 1000),
                0
              ) + 1;

            initializeCanvas();
            updateUIState();
            setProgress(false);
          };
          imgElement.src = historyEntry.imageData;
        };

        const initializeCanvas = () => {
          if (!image) return;
          els.canvas.width = canvasArea.clientWidth;
          els.canvas.height = canvasArea.clientHeight;
          redrawCanvas();
        };

        const redrawCanvas = () => {
          if (!image) return;
          ctx.clearRect(0, 0, els.canvas.width, els.canvas.height);
          const imgRatio = image.width / image.height;
          const canvasRatio = els.canvas.width / els.canvas.height;
          let dw, dh, dx, dy;
          if (imgRatio > canvasRatio) {
            dw = els.canvas.width;
            dh = dw / imgRatio;
            dx = 0;
            dy = (els.canvas.height - dh) / 2;
          } else {
            dh = els.canvas.height;
            dw = dh * imgRatio;
            dy = 0;
            dx = (els.canvas.width - dw) / 2;
          }
          currentImageRenderInfo = { x: dx, y: dy, width: dw, height: dh };
          ctx.drawImage(image.image, dx, dy, dw, dh);

          const labelRects = [];
          if (showAnnotations) {
            annotations.forEach((anno) => drawAnnotation(anno, labelRects));
          }
          if (isDrawing && maskPoints.length > 0) {
            drawCurrentMask();
          }
        };

        const drawPolygon = (points) => {
          if (points.length < 2) return;
          ctx.beginPath();
          ctx.moveTo(points[0], points[1]);
          for (let i = 2; i < points.length; i += 2) {
            ctx.lineTo(points[i], points[i + 1]);
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        };

        const drawLabel = (text, scaledMaskPoints, category, labelRects) => {
          const fontSize = 12;
          ctx.font = `bold ${fontSize}px Inter`;
          const padding = 4;
          const textMetrics = ctx.measureText(text);
          const rectWidth = textMetrics.width + padding * 2;
          const rectHeight = fontSize + padding * 2;

          let minX = Infinity,
            maxX = -Infinity,
            minY = Infinity;
          for (let i = 0; i < scaledMaskPoints.length; i += 2) {
            minX = Math.min(minX, scaledMaskPoints[i]);
            maxX = Math.max(maxX, scaledMaskPoints[i]);
            minY = Math.min(minY, scaledMaskPoints[i + 1]);
          }

          let labelX = (minX + maxX) / 2 - rectWidth / 2;
          let labelY = minY - rectHeight - 5;

          // Assure que le label reste dans les limites du canvas.
          labelX = Math.max(
            padding,
            Math.min(labelX, els.canvas.width - rectWidth - padding)
          );
          labelY = Math.max(
            padding,
            Math.min(labelY, els.canvas.height - rectHeight - padding)
          );

          // Évite le chevauchement basique des labels.
          let isOverlapping = labelRects.some(
            (r) =>
              labelX < r.x + r.width &&
              labelX + rectWidth > r.x &&
              labelY < r.y + r.height &&
              labelY + rectHeight > r.y
          );
          if (isOverlapping) labelY = Math.max(minY, labelY) + rectHeight + 5;

          labelRects.push({
            x: labelX,
            y: labelY,
            width: rectWidth,
            height: rectHeight,
          });

          ctx.fillStyle = "rgba(15, 15, 20, 0.7)";
          ctx.fillRect(labelX, labelY, rectWidth, rectHeight);
          ctx.fillStyle = category.color;
          ctx.textBaseline = "top";
          ctx.fillText(text, labelX + padding, labelY + padding);
        };

        const drawAnnotation = (anno, labelRects) => {
          const category = CATEGORIES[anno.category_id];
          if (!category) return;

          const scaleX = currentImageRenderInfo.width / image.width;
          const scaleY = currentImageRenderInfo.height / image.height;
          const scaledMask = anno.segmentation[0].map((val, i) =>
            i % 2 === 0
              ? val * scaleX + currentImageRenderInfo.x
              : val * scaleY + currentImageRenderInfo.y
          );

          ctx.fillStyle = category.color
            .replace("rgb", "rgba")
            .replace(")", ", 0.3)");
          ctx.strokeStyle = category.color;
          ctx.lineWidth = 2;

          drawPolygon(scaledMask);
          drawLabel(category.displayName, scaledMask, category, labelRects);
        };

        const drawCurrentMask = () => {
          ctx.strokeStyle = CATEGORIES[currentCategory].color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          maskPoints.forEach((p, i) => {
            const drawX = p.x + currentImageRenderInfo.x;
            const drawY = p.y + currentImageRenderInfo.y;
            i === 0 ? ctx.moveTo(drawX, drawY) : ctx.lineTo(drawX, drawY);
          });
          ctx.stroke();
        };

        const finalizeMask = () => {
          if (maskPoints.length < 3) {
            maskPoints = [];
            isDrawing = false;
            redrawCanvas();
            return;
          }
          const scaleX = image.width / currentImageRenderInfo.width;
          const scaleY = image.height / currentImageRenderInfo.height;

          const segmentation = [[]];
          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;

          maskPoints.forEach((p) => {
            const originalX = Math.round(p.x * scaleX);
            const originalY = Math.round(p.y * scaleY);
            segmentation[0].push(originalX, originalY);
            minX = Math.min(minX, originalX);
            minY = Math.min(minY, originalY);
            maxX = Math.max(maxX, originalX);
            maxY = Math.max(maxY, originalY);
          });

          annotations.push({
            id: image.id * 1000 + image.annotationIndex++,
            image_id: image.id,
            category_id: currentCategory,
            bbox: [minX, minY, maxX - minX, maxY - minY],
            area: 0,
            segmentation: segmentation,
            iscrowd: 0,
          });

          maskPoints = [];
          isDrawing = false;
          undoneAnnotations = [];
          isSaved = false;
          redrawCanvas();
        };

        const selectCategory = (id) => {
          if (isViewOnly) return; // Empêche la sélection de catégorie en mode lecture seule.
          currentCategory = parseInt(id);
          document.querySelectorAll(".category-btn").forEach((btn) => {
            btn.classList.toggle(
              "active",
              parseInt(btn.dataset.category) === currentCategory
            );
          });
        };

        // --- ACTIONS & SAUVEGARDE ---
        const undo = () => {
          if (isViewOnly) return; // Empêche l'annulation en mode lecture seule.
          if (maskPoints.length > 0) {
            maskPoints = [];
            isDrawing = false;
          } else if (annotations.length > 0) {
            undoneAnnotations.push(annotations.pop());
          }
          isSaved = false;
          redrawCanvas();
        };
        const redo = () => {
          if (isViewOnly || undoneAnnotations.length === 0) return; // Empêche la répétition en mode lecture seule.
          annotations.push(undoneAnnotations.pop());
          isSaved = false;
          redrawCanvas();
        };
        const clearAll = () => {
          if (
            isViewOnly ||
            (annotations.length === 0 && maskPoints.length === 0)
          )
            return; // Empêche d'effacer en mode lecture seule ou s'il n'y a rien à effacer.
          showConfirmModal(
            "Tout effacer",
            "Voulez-vous vraiment supprimer toutes les annotations ?",
            () => {
              annotations.length = 0;
              maskPoints = [];
              isDrawing = false;
              isSaved = false;
              redrawCanvas();
            }
          );
        };

        const saveAll = () => {
          if (!image) return;
          if (annotations.length === 0) {
            showNoAnnotationMessage(); // Affiche le message "Pas d'annotations".
            return;
          }

          setProgress(true);
          const jsonData = {
            images: [
              {
                file_name: image.file_name,
                height: image.height,
                width: image.width,
                id: image.id,
              },
            ],
            annotations: annotations,
            categories: Object.values(CATEGORIES),
          };
          const jsonBlob = new Blob([JSON.stringify(jsonData, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(jsonBlob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${image.file_name.split(".")[0]}_annotations.json`;
          a.click();
          URL.revokeObjectURL(url);

          // Utilise l'image originale pour l'historique (pas de réduction de qualité).
          const historyEntry = {
            fileName: image.file_name,
            imageData: image.dataURL,
            annotations: JSON.parse(JSON.stringify(annotations)), // Copie profonde des annotations.
            imageId: image.id,
            timestamp: new Date().toISOString(),
          };
          // Supprime l'ancienne entrée si le même fichier est resauvegardé pour éviter les doublons.
          let history = getHistory().filter(
            (item) => item.fileName !== historyEntry.fileName
          );
          history.push(historyEntry);
          saveHistory(history);

          isSaved = true;
          setProgress(false);
        };

        const checkUnsavedChanges = (callback) => {
          // Vérifie si une image est chargée, s'il y a des annotations et si elles ne sont pas sauvegardées.
          if (image && annotations.length > 0 && !isSaved) {
            toggleModal("imageChangeModal", true);
            els.saveAndChangeBtn.onclick = () => {
              saveAll();
              callback(); // Exécute le callback immédiatement après saveAll.
              toggleModal("imageChangeModal", false);
            };
            els.changeWithoutSavingBtn.onclick = () => {
              isSaved = true; // Marque comme sauvegardé pour éviter la boucle de confirmation.
              callback();
              toggleModal("imageChangeModal", false);
            };
          } else {
            callback();
          }
        };

        // --- GESTION DES ÉVÉNEMENTS ---
        const getTransformedPos = (clientX, clientY) => {
          const rect = els.canvas.getBoundingClientRect();
          const x =
            (clientX - rect.left) * (els.canvas.width / rect.width) -
            currentImageRenderInfo.x;
          const y =
            (clientY - rect.top) * (els.canvas.height / rect.height) -
            currentImageRenderInfo.y;
          // Retourne null si le clic est en dehors de l'image rendue sur le canvas.
          if (
            x < 0 ||
            y < 0 ||
            x > currentImageRenderInfo.width ||
            y > currentImageRenderInfo.height
          ) {
            return null;
          }
          return { x, y };
        };

        const handleDrawStart = (e) => {
          if (isViewOnly || !image) return; // Empêche le dessin en mode lecture seule ou sans image.
          e.preventDefault();
          const pos = getTransformedPos(
            e.clientX ?? e.touches[0].clientX,
            e.clientY ?? e.touches[0].clientY
          );
          if (!pos) return;
          isDrawing = true;
          maskPoints = [pos];
        };

        const handleDrawMove = (e) => {
          if (!isDrawing) return;
          e.preventDefault();
          const pos = getTransformedPos(
            e.clientX ?? e.touches[0].clientX,
            e.clientY ?? e.touches[0].clientY
          );
          if (!pos) return;
          maskPoints.push(pos);
          redrawCanvas();
        };

        const handleDrawEnd = () => {
          if (!isDrawing) return;
          isDrawing = false;
          finalizeMask();
        };

        // --- INITIALISATION ---
        const init = () => {
          setupModals();
          updateUIState(); // Mise à jour initiale de l'interface utilisateur.

          els.newImageBtn.onclick = () =>
            checkUnsavedChanges(() => els.imageInput.click());
          els.imageInput.onchange = (e) =>
            e.target.files[0] && loadImage(e.target.files[0]);
          els.saveBtn.onclick = debounce(saveAll, 300);
          els.historyBtn.onclick = showHistoryModal;
          els.clearHistoryBtn.onclick = clearAllHistory;

          els.toggleAnnotationsBtn.onclick = () => {
            showAnnotations = !showAnnotations;
            els.toggleAnnotationsBtn.querySelector(
              "i"
            ).className = `fas fa-eye${showAnnotations ? "" : "-slash"}`;
            redrawCanvas();
          };
          els.tutorialBtn.onclick = () => toggleModal("tutorialModal", true);
          els.undoBtn.onclick = undo;
          els.redoBtn.onclick = redo;
          els.clearAllBtn.onclick = clearAll;

          // Attache les écouteurs d'événements aux boutons de catégorie.
          document.querySelectorAll(".category-btn").forEach((button) => {
            button.onclick = () => selectCategory(button.dataset.category);
          });

          // Écouteurs d'événements pour le dessin sur le canvas (souris et tactile).
          els.canvas.addEventListener("mousedown", handleDrawStart);
          els.canvas.addEventListener("mousemove", handleDrawMove);
          els.canvas.addEventListener("mouseup", handleDrawEnd);
          els.canvas.addEventListener("mouseleave", handleDrawEnd);
          els.canvas.addEventListener("touchstart", handleDrawStart, {
            passive: false,
          });
          els.canvas.addEventListener("touchmove", handleDrawMove, {
            passive: false,
          });
          els.canvas.addEventListener("touchend", handleDrawEnd, {
            passive: false,
          });
          els.canvas.addEventListener("contextmenu", (e) => e.preventDefault()); // Empêche le menu contextuel du clic droit.

          // Gestion du glisser-déposer d'images.
          ["dragenter", "dragover", "dragleave", "drop"].forEach((evt) => {
            canvasArea.addEventListener(
              evt,
              (e) => {
                e.preventDefault();
                e.stopPropagation();
              },
              false
            );
          });
          canvasArea.addEventListener("drop", (e) => {
            const file = e.dataTransfer.files[0];
            checkUnsavedChanges(() => loadImage(file));
          });

          // Raccourcis clavier (Annuler/Refaire).
          window.addEventListener("keydown", (e) => {
            if (document.querySelector(".modal-overlay.active")) return; // Ignorer les raccourcis si une modale est ouverte.
            if (e.ctrlKey && e.key === "z") undo();
            if (e.ctrlKey && e.key === "y") redo();
          });

          // Redimensionnement du canvas avec la fenêtre, avec debounce pour optimiser.
          window.addEventListener("resize", debounce(initializeCanvas, 200));
        };

        // Lancement de l'initialisation de l'application.
        init();
      });
    </script>
  </body>
</html>
